+++
date = "2019-11-15T11:00:00-05:00"
title = "Zygote: It's alive!"
author = "AJ Frantz"
+++

As I mentioned in my previous post, Zygote has open loop motor spinning
capability.  It's nothing impressive yet, and the progress has been slow due to
a number of Life Happens events recently, but I thought I'd give a quick recap
of what's been going on so far--particularly my thoughts on Rust to date.

First, the moderately pointless but still enjoyable eye candy demo:

<iframe width="853" height="480"
src="https://www.youtube-nocookie.com/embed/uoiJREiLmwA" frameborder="0"
allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
allowfullscreen></iframe>

So!  Let's dive in.

<!--more-->

## Black Magic Probe

In my [previous post](/post/2019-10-08-zygote-rust-experiment/) I mentioned
that I was going to try out using the [Black Magic
Probe](https://1bitsquared.com/products/black-magic-probe) as my debugger for
this project.  My only hesitation was a lack of support for the STM32G4 series,
but it seems like a well-run open source project with obvious and
easy-to-follow contributor instructions for adding it.

Well!  I'm happy to report that I didn't have to add it after all.  The
firmware that came on my probe from the factory did not recognize the STM32G4,
but as soon as I forked the project and uploaded a clean build of `master` the
probe started working exactly as designed.  So, it wasn't quite out of the box,
but with only ~10 minutes of reading build instructions and one reflash command
required, I'd say the setup was easier than OpenOCD would have been.

I've been using the probe daily (well, at least for days where I get to work on
Zygote) and have had essentially zero issues with it.  Highly recommended!

## rust-embedded / community support

One of the reasons for picking an STM32 product--though certainly not the only
one--was the seemingly higher level of support for the family within the
rust-embedded community.  Specifically there are plenty of tutorials, HAL
crates, and register access crates all provided for many of the common
families.  Unfortunately, this support hasn't really been paying off for me as
much as I had hoped.

The rust-embedded community has been rallying around a tool called
[svd2rust](https://docs.rs/svd2rust/0.16.1/svd2rust/) in order to the the
vendor-provided documentation for chips and automatically generate code to
program the various memory-mapped registers on the device.  I think this is a
great _concept_, but in practice I've always been leery of vendor support for
software.  Most vendors ship gnarly autogenerated beehives of buggy BSP
support, generally written by interns and relatively untested.  The maker
community has made some headway here--the Mbed project has generally higher
quality that most BSPs--but overall I've been burned by vendor code enough
times to not trust it much.

In this case my mistrust was at least _a little_ well founded.  I found that
the STM32G4 support in the community's code base was relatively recent, and
perhaps as a result, relatively untested.  The vendor's SVD did not match the
reference manual, and had several serious bugs in some cases.  I
[PR'd](https://github.com/stm32-rs/stm32-rs/pull/294) fixes for the first
module I worked on, which resolved those issues for now.  However, pulling
those changes into my project was a bit tricky, because the repository is used
to generate a package, so I couldn't just point at my fork.  I generated the
package locally, but that would have been more difficult to coordinate if I
were working with a larger team.

Ultimately I'm not a _huge_ fan of the `svd2rust` peripheral access API--I like
the theory, but the ergonomics are a bit 'off' to me, and if I'm going to have
to manually audit every section of the SVD the auto-generation doesn't buy me
much anyway.  I worked up an alternate register access API that's a bit more
self-contained and used it for my next driver implementation.  That's gone
reasonably well, and I'll post about it later once I've tried it on a few more
modules.

## Siglent SDS 1104X-E

Any embedded project with non-trivial interfaces pretty much demands having a
way to "see" what your circuits are doing.  The best tool for that is probably
an oscilloscope, and I after years of 'borrowing' I found myself in a place
where I didn't have access to one.  Enter the [Siglent SDS
1104X-E](https://www.amazon.com/Siglent-SDS1104X-oscilloscope-Channels-Standard/dp/B07PV2MQVT).

My requirements were basically: 4 channels, 50+ MHz bandwidth, and a modern
interface.  The conventional suggestion is generally the [Rigol
DS1054Z](https://www.amazon.com/Rigol-DS1054Z-Digital-Oscilloscopes-Bandwidth/dp/B012938E76),
but I've used that model in the past and the UI feels clunky, and you have to
'hack' things a bit if you want the best experience out of the device.

This time around I splurged a _very little_ bit more ($500 vs. $350) and got
double the bandwidth, no hacking required, and a scope that feels much closer
to the higher end products that I'm used to.  After using it for a little bit
I'll admit--you're never going to confuse it with a [Keysight
MSOX3054T](https://www.keysight.com/en/pdx-x202187-pn-MSOX3054T/mixed-signal-oscilloscope-500-mhz-4-analog-plus-16-digital-channels?cc=US&lc=eng),
but at approximately 3.7% of the price... my home-lab choice is clear.

## Distractions

I spent some nontrivial amount of time not working on the motor controller.
We'll chalk that up to wanting to diversify my Rust experience, and it
certainly has not been without it's share of learning experiences.  At some
point soon I'll start sending diagnostic data and commands over a serial link,
and in preparation for that I played around with
[bit-stuffing](https://github.com/ajfrantz/stuff-it) a little bit, implementing
the venerable COBS encoding.  I had some fun on that, introducing both
property-based testing via [proptest](https://docs.rs/proptest/0.9.4/proptest/)
and fuzzing of the decoder via [cargo
fuzz](https://rust-fuzz.github.io/book/cargo-fuzz.html).

[Async/await went
stable](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html) in the
meantime, so I spent several days learning how it works internally and as an
exercise to solidify my understanding I built out [an async-friendly ring
buffer](https://github.com/ajfrantz/wait-around) that might be useful if I
decide to try and dive deeper into using `async` in my embedded projects.  I'm
not entirely sold yet, mainly for two reasons: `async` seems to add a lot of
complexity (particularly, it's not usable in traits without heap usage right
now), and because executors for embedded devices (like [this
one](https://github.com/Nemo157/embrio-rs)) seem to be relatively immature
right now.  Then again, maybe I'll write my own... :)

Lastly, I started drafting up some code related to the [MQTT
protocol](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html).  I
implemented packet encoding/decoding for protocol version 5, which may have
been a mistake--there's a lot more of what I'd call "bloat" in v5 than in the
previous versions (like v3.1.1).  I used `nom` to generate a zero-copy parser
of the packets for decoding, and that's led to a lot of complicated lifetime
issues.  For example, I've wound up with `Message` and `OwnedMessage` classes
which operate similar to `&str` and `String`.  Looking around the community
this isn't necessarily an uncommon pattern, but the ergonomics on this don't
feel great and so for the moment I've kept the repository private on GitHub.

My original goal was to see how I could blend `async` with a `no_std` MQTT
client for embedded, but with my `async` reservations and the current state of
the project, I'll probably let some of this fall off for a while as I return to
core motor controller pieces and ruminate on the longer-term solution a bit
more when the requirements are more clear.  That said, I was able to exercise
property-based testing some more--easily finding 2 or 3 tricky bugs.  I also
deployed fuzzing, which doesn't assert parsing is _correct_ but does give some
confidence about memory safety; naturally it found no issues, which is
promising since that's Rust's entire MO.

Speaking of `nom` though--there's a new major version out for it (5) and the
primary API is now functions instead of macros.  I found this much simpler to
wrap my head around, the error messages are much more ergonomic, and generally
_most_ of the things that turned me off about `nom` in the past seem to be much
improved.  [Check it out
again](http://unhandledexpression.com/general/2019/06/17/nom-5-is-here.html) if
you've been discouraged in the past!

Lastly, I've been doing some interviewing about town, and to freshen up before
doing so I worked through a bunch of problems on
[leetcode](https://leetcode.com/).  Their environment was functional enough,
and the problems not unreasonable.  At my experience level I only found it
worthwhile to even attempt solving their 'hard' problems, and after completing
~20 of them or so with at least median-beating performance/memory consumption
I'll say that there's nothing really special going on here.  These are all more
or less classic "whiteboard interview" problems, and you get exactly what's on
the tin: maybe not a great judge of someone's ability, but hopefully a jumping
off point for more interesting technical discussions.  Anyway, if you're
looking for whiteboard interview practice, there are worse ways you can spend
your time--if you're looking for fun puzzles, though, maybe just wait for this
year's [Advent of Code](https://adventofcode.com/)!
